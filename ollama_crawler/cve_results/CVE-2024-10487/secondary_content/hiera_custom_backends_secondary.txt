Title: Writing new data backends
URL: https://www.puppet.com/docs/puppet/7/hiera_custom_backends

Puppet.com
Forge
Education


                                    Try Puppet
                                


































        Docs
        






Products
Puppet Enterprise
Open Source Puppet
Bolt
Security Compliance Management
Continuous Delivery
Puppet Development Kit
Puppet DB
Puppet Plugin for VMware



        Support
        






Get
Technical Support Plans
Support Lifecycle Policy
New Puppet Enterprise Customer?



        Community
        






About Puppet
Company
Developer Experience
Community
Puppet Champions
Puppet Test Pilots
Community Calendar
Slack Channel







 









































PRODUCT AND VERSION


      Current product
      










      Current version
      








Puppet  7.34.0

Release notes

Puppet release notes
Puppet  7.34.0Security


Puppet known issues
Puppet Server release notes
Puppet Server known Issues
PuppetDB release notes (link)

Facter release notes
Facter 4.10.0
Facter 4.9.0
Facter 4.8.0
Facter 4.7.1
Facter 4.7.0
Facter 4.6.1
Facter 4.6.0
Facter 4.5.2


Facter known issues
What's new since Puppet 6?
Upgrading from Puppet 6 to Puppet 7

Experimental featuresMsgpack support

Archived documentation



Puppet overview
What is Puppet?
Why use Puppet desired state management?
Key concepts behind Puppet
The Puppet platform 
Puppet platform lifecycle 
Open source Puppet vs Puppet Enterprise (PE)
The Puppet ecosystem
Use cases
Glossary
Navigating the documentation



Set up Puppet

Install Puppet
System requirements
Installing Puppet  
Installing and configuring agents
Manually verify packages
Managing Platform versions



Configure Puppet settings
Puppet settings
Key configuration settings

Puppet's configuration files
puppet.conf: The main config file
environment.conf: Per-environment settings
fileserver.conf: Custom fileserver mount points
puppetdb.conf: PuppetDB server locations
autosign.conf: Basic certificate autosigning 
csr_attributes.yaml: Certificate extensions 
custom_trusted_oid_mapping.yaml: Short names for cert extension OIDs
device.conf: Network hardware access
routes.yaml: Advanced plugin routing


Adding file server mount points
Checking the values of settings
Editing settings on the command line
Configuration Reference



Upgrading
Upgrade Puppet Server

Upgrade agents
Upgrade agents using the puppet_agent module
Upgrade *nix agents
Upgrade Windows agents
Upgrade macOS agents


Upgrade PuppetDB



Environments
About environments
Creating environments
Environment isolation



Directories and files
Code and data directory (codedir)
Config directory (confdir)
Main manifest directory
The modulepath
SSL directory (ssldir)
Cache directory (vardir)


Report reference



Platform components

Puppet Server
About Puppet Server
Deprecated features
Server and agent compatibility
Installing Puppet Server

Configuring Puppet Server
Configuring Puppet Server

Puppet Server configuration files
auth.conf
ca.conf
global.conf
logback.xml
metrics.conf
product.conf
puppetserver.conf
web-routes.conf
webserver.conf


Migrating to the HOCON auth.conf format
Advanced logging configuration
Differing behavior in puppet.conf



Using and extending Puppet Server
Subcommands
Using Ruby gems
Intermediate CA
Infrastructure certificate revocation list (CRL)
External SSL termination

Server metrics
Monitoring Puppet Server metrics
HTTP Client Metrics


Tuning guide
Applying metrics to improve performance
Submitting usage telemetry
Scaling Puppet Server
Restarting Puppet Server"



Developer information
Developer debugging
Running from source
Tracing code events



Puppet Server HTTP API
Puppet Server HTTP API overview
PSON

Puppet v3 API
Catalog
Node
Facts
File Bucket File
File Content
File Metadata
Report



Puppet v4 APICatalog API


CA v1 API
Certificate
Certificate Request
Certificate Status
Certificate Revocation List
Expirations
Certificate Clean


Schemas (JSON)



API endpoints

Metrics API endpoints
v1 metrics
v2 (Jolokia) metrics



Status API endpoints
Services endpoint
Simple endpoint



Administrative API endpoints
Environment cache
JRuby pool



Server-specific Puppet API endpoints
Environment classes
Environment modules
Static file content





Certificate authority and SSL
Puppet Server CA commands
Intermediate CA
Autosigning certificate requests
CSR attributes and certificate extensions
Regenerating certificates in a Puppet deployment
External CA
External SSL termination





Facter  
Facter: CLI
Facter: Core Facts

Custom facts overviewEnvironment facts 

Writing custom facts
External facts
Configuring Facter with facter.conf


PuppetDB

Puppet services and tools
Puppet commands
Running Puppet commands on Windows  

primary Puppet serverAbout Puppet Server

Puppet agent on *nix systems
Puppet agent on Windows
Puppet apply
Puppet device



Puppet reports
Reporting
Report reference
Writing custom report processors
Report format



Life cycle of a Puppet run
Agent-server HTTPS communications
Catalog compilation
Static catalogs 





Using Puppet code
Classifying nodes
Managing environment content with a Puppetfile
Using content from Puppet Forge

Designing system configs (roles and profiles)
The roles and profiles method 
Roles and profiles example 
Designing advanced profiles 
Designing convenient roles 



Separating data (Hiera)
About Hiera  
Getting started with Hiera  
Configuring Hiera
Creating and editing data 
Looking up data with Hiera  
Writing new data backends 

Debugging Hiera
Unexpected values
Common errors


Upgrading to Hiera 5 



Use case examples
Manage NTP
Manage sudo 
Manage DNS
Manage firewall rules
Forge examples





Syntax and settings

The Puppet language
Puppet language overview
Puppet language syntax examples
The Puppet language style guide 
Files and paths on Windows  
Code comments 
Variables
Resources

Resource types
Resource Type Reference (Single-Page)
Built-in types
Optional resource types for Windows
Resource Type: exec
Using exec on Windows  
Resource Type: file
Using file on Windows
Resource Type: filebucket
Resource Type: group
Using user and group on Windows
Resource types overview
Resource Type: notify
Resource Type: package
Using package on Windows  
Resource Type: resources
Resource Type: schedule
Resource Type: service
Using service
Resource Type: stage
Resource Type: tidy
Resource Type: user


Relationships and ordering
Classes
Defined resource types
Bolt tasks
Expressions and operators
Conditional statements and expressions
Function calls
Built-in function reference
Node definitions

Facts and built-in variables
Accessing facts from Puppet code
Built-in variables


Reserved words and acceptable names

Custom resources

Develop types and providers with the Resource APIResource API reference


Low-level method for developing types and providers
Type development
Provider development
Creating resources





Custom functions
Custom functions overview 
Writing custom functions in the Puppet language

Writing custom functions in Ruby
Custom functions in Ruby overview
Ruby function signatures
Using special features in implementation methods
Iterative functions
Refactoring legacy 3.x functions



Deferring a function
Deferred functions overview
Using a template with Deferred values
Write a deferred function to store secrets
Integrations with secret stores





Values, data types, and aliases
Type aliases
Typecasting
Abstract data types
Arrays
Binary
Booleans
Data type syntax
Default
Error data type
Hashes
Numbers
Regular expressions
Resource and class references
Resource types
Sensitive
Strings
Time-related data types
Undef



Templates
Creating templates using Embedded Puppet
Creating templates using Embedded Ruby



Advanced constructs
Iteration and loops
Lambdas
Resource default statements
Resource collectors
Virtual resources
Exported resources
Tags
Run stages



Details of complex behaviors
Containment
Scope
Namespaces and autoloading


Securing sensitive data


Metaparameter reference
Configuration Reference
Built-in function reference

Puppet Man Pages

Core tools
Man Page: puppet agent
Man Page: puppet apply
Man Page: puppet module
Man Page: puppet resource
Man Page: puppet lookup



Occasionally useful
Man Page: puppet config
Man Page: puppet describe
Man Page: puppet device
Man Page: puppet doc
Man Page: puppet help
Man Page: puppet node
Man Page: puppet parser



Niche
Man Page: puppet catalog
Man Page: puppet facts
Man Page: puppet filebucket
Man Page: puppet report







Developing modules

Modules
Modules overview
Plug-ins in modules
Module cheat sheet
Installing and managing modules from the command line
Beginner's guide to writing modules
Module metadata
Documenting modules
Documenting modules with Puppet Strings  
Puppet Strings style guide

Publishing modulesUsing the Forge API

Contributing to Puppet modules


Puppet Development Kit (PDK)
Puppet VSCode extension

PowerShell DSC Resources
Converting DSC Resources
Distributing arbitrary DSC resources
Upgrading Puppet DSC modules 
Troubleshooting DSC Resources 


Ruby API for developing extensions


Writing new data backends 

You can extend Hiera to
        look up values in data sources, for example, a PostgreSQL database table, a custom web app,
        or a new kind of structured data file.
To teach Hiera how to talk to other
            data sources, write a custom backend.

Important: Writing a custom backend
                is an advanced topic. Before proceeding, make sure you really need it. It is also
                worth asking the puppet-dev mailing list or Slack channel to see whether there is
                one you can re-use, rather than starting from scratch.


Custom backends overview 

A backend is a custom Puppet function that accepts a particular set of arguments and whose return value obeys a
        particular format. The function can do whatever is necessary to locate its data.
A backend function uses the modern Ruby
            functions API or the Puppet language. This means you can
            use different versions of a Hiera backend in different
            environments, and you can distribute Hiera backends in
                Puppet modules.
Different types of data have different performance characteristics. To
            make sure Hiera performs well with every type of data
            source, it supports three types of backends: data_hash, lookup_key,
            and data_dig.

data_hash

For data sources where it’s inexpensive, performance-wise, to read the entire
                contents at one time, like simple files on disk. We suggest using the data_hash backend type if: 

The cache is alive for the duration of one compilation


The data is small


The data can be retrieved all at one time


Most of the data gets used


The data is static



For more information, see data_hash
                    backends.


lookup_key

For data sources where looking up a key is relatively expensive, performance-wise,
                like an HTTPS API. We suggest using the lookup_key
                backend type if:

The data set is big, but only a small portion is used


The result can vary during the compilation

The hiera-eyaml backend is a lookup_key function, because decryption tends to affect
                performance; as a given node uses only a subset of the available secrets, it makes
                sense to decrypt only on-demand.
For more information, see lookup_key
                    backends.


data_dig

For data sources that can access arbitrary elements of hash or array values before
                passing anything back to Hiera, like a database.
For more information, see data_dig
                backends.

The RichDataKey and RichData types
To simplify backend function signatures, you can use two extra data type aliases:
                    RichDataKey and RichData. These are only available to backend functions called by Hiera; normal functions and Puppet code can not use them.
For more information, see custom Puppet functions, the modern
                    Ruby functions API.




data_hash backends 

A data_hash
    backend function reads an entire data source at one time, and returns its contents as a
    hash.
The built-in YAML, JSON, and HOCON
        backends are all data_hash functions. You
        can view their source on GitHub: 

yaml_data.rb


json_data.rb


hocon_data.rb



Arguments

Hiera calls a data_hash
        function with two arguments: 

A hash of options 


The options hash contains a path when the entry
                  in hiera.yaml is using path, paths, glob, globs, or mapped_paths,
                  and the backend receives one call per path to an existing file. When the entry in
                    hiera.yaml is using uri or uris, the options hash has a
                    uri key, and the backend function is called one
                  time per given uri. When uri or uris are used, Hiera does
                  not perform an existence check. It is up to the function to type the options
                  parameter as wanted. 




A Puppet::LookupContext object 




Return type
The function must either call the context object’s not_found method, or return a hash of lookup keys and their associated values.
        The hash can be empty.

Puppet language example
        signature:function mymodule::hiera_backend(
  Hash                  $options,
  Puppet::LookupContext $context,
)


Ruby example signature:

dispatch :hiera_backend do
  param 'Hash', :options
  param 'Puppet::LookupContext', :context
end

The returned hash can include the lookup_options key to
        configure merge behavior for other keys. See Configuring merge behavior in Hiera data for more information. Values in the returned hash
        can include Hiera interpolation tokens like %{variable} or %{lookup('key')};
          Hiera interpolates values as needed. This is a significant
        difference between data_hash and the other two backend
        types; lookup_key and data_dig functions have to explicitly handle interpolation.



Related informationconfigure_merge_behavior_hiera.html


lookup_key backends 

A lookup_key backend function looks up a single key and returns its value. For
    example, the built-in hiera_eyaml backend is a
      lookup_key function. 
You can view its source on Git at eyaml_lookup_key.rb.
Arguments

Hiera calls a lookup_key function with
        three arguments: 

A key to look up.


A hash of options.


A Puppet::LookupContext object.




Return type 
The function must either call the context object’s not_found method, or
        return a value for the requested key. It can return undef as a value.

Puppet language example
          signature:function mymodule::hiera_backend(
  Variant[String, Numeric] $key,
  Hash                     $options,
  Puppet::LookupContext    $context,
)
Ruby example
        signature:dispatch :hiera_backend do
  param 'Variant[String, Numeric]', :key
  param 'Hash', :options
  param 'Puppet::LookupContext', :context
endA lookup_key function can return a hash for the the
          lookup_options key to configure merge behavior for other keys. See
        Configuring merge behavior in Hiera data for more
        information. To support Hiera interpolation tokens, for
        example, %{variable} or %{lookup('key')} in your data,
        call context.interpolate on your values before returning them.



Related information
Interpolation
Hiera calling conventions for backend functions



data_dig backends 

A data_dig
    backend function is similar to a lookup_key
    function, but instead of looking up a single key, it looks up a single sequence of keys and
    subkeys.

Hiera
        lets you look up individual members of hash and array values using key.subkey notation. Use data_dig types in cases where: 
Lookups are relatively expensive.
The data source knows how to extract
              elements from hash and array values. 
Users are likely to pass key.subkey requests to the lookup function to access subsets of large data
              structures.


Arguments

Hiera calls a data_dig function with three
        arguments: 

An array of lookup key segments, made by splitting the requested lookup key on the
              dot (.) subkey separator. For example, a lookup for
                users.dbadmin.uid results in ['users', 'dbadmin',
                'uid']. Positive base-10 integer subkeys (for accessing array members) are
              converted to Integer objects, but other number subkeys remain as strings.


A hash of options.


A Puppet::LookupContext object.




Return type 
The function must either call the context object’s not_found method, or
        return a value for the requested sequence of key segments. Note that returning undef (nil in
          Ruby) means that the key was found but that the value for
        that key was specified to be undef. Puppet language example
          signature:function mymodule::hiera_backend(
  Array[Variant[String, Numeric]] $segments,
  Hash                            $options,
  Puppet::LookupContext           $context,
)
Ruby example
        signature:dispatch :hiera_backend do
  param 'Array[Variant[String, Numeric]]', :segments
  param 'Hash', :options
  param 'Puppet::LookupContext', :context
end

A data_dig function can return a hash for the the
          lookup_options key to configure merge behavior for other keys. See
        Configuring merge behavior in Hiera data for more info.
To support Hiera interpolation tokens like
          %{variable} or %{lookup('key')} in your data, call
          context.interpolate on your values before returning them.



Related information
configure_merge_behavior_hiera.html
Access hash and array elements using a key.subkey notation



Hiera calling conventions for backend
                        functions 


Hiera uses the following conventions when
                        calling backend functions.

Hiera calls data_hash one time
                                    per data source, calls lookup_key functions one time per data
                                    source for every unique key lookup, and calls data_dig functions
                                    one time per data source for every unique sequence of key
                                    segments.
However, a given hierarchy level can refer to multiple
                                    data sources with the path, paths, uri, uris,
                                                glob, and globs settings. Hiera handles each
                                    hierarchy level as follows:

If the path, paths, glob, or
                                                  globs settings are used, Hiera determines which
                                                files exist and calls the function one time for
                                                each. If no files were found, the function is not be
                                                called.
If the uri or uris settings are
                                                used, Hiera calls the
                                                function one time per URI.
If none of those settings are used, Hiera calls the
                                                function one time.


Hiera can call a function again
                                    for a given data source, if the inputs change. For example, if
                                                hiera.yaml interpolates a local variable
                                    in a file path, Hiera calls the
                                    function again for scopes where that variable has a different
                                    value. This has a significant performance impact, so you must
                                    interpolate only facts, trusted facts, and server facts in the
                                    hierarchy.


The options hash 

Hierarchy levels are configured in the hiera.yaml file. When calling a backend
    function, Hiera passes a modified version of that configuration
    as a hash.
The options hash can contain (depending on whether path, glob, uri, ormapped_paths have been set) the following keys: 
path - The absolute path to a file on disk. It is present only
            if path, paths, glob, globs, or mapped_paths is present in the hierarchy. Hiera never calls the function unless the file is present.
          
uri - A uri that your function can use to locate a data
            source. It is present only if uri or uris
            is present in the hierarchy. Hiera does not verify the
            URI before passing it to the function.
Every key from the hierarchy level’s options setting. List any
            options your backend requires or accepts. The path and uri keys are reserved.



Note: If your backend uses data files,
        use the context object’s cached_file_data method to read them.
For example, the following hierarchy level in hiera.yaml results in several different options
      hashes, depending on such things as the current node’s facts and whether the files exist:
- name: "Secret data: per-node, per-datacenter, common"
    lookup_key: eyaml_lookup_key # eyaml backend
    datadir: data
    paths:
      - "secrets/nodes/%{trusted.certname}.eyaml"
      - "secrets/location/%{facts.whereami}.eyaml"
      - "common.eyaml"
    options:
      pkcs7_private_key: /etc/puppetlabs/puppet/eyaml/private_key.pkcs7.pem
      pkcs7_public_key:  /etc/puppetlabs/puppet/eyaml/public_key.pkcs7.pem
The various hashes would all be similar to this:
{
  'path' => '/etc/puppetlabs/code/environments/production/data/secrets/nodes/web01.example.com.eyaml',
  'pkcs7_private_key' => '/etc/puppetlabs/puppet/eyaml/private_key.pkcs7.pem',
  'pkcs7_public_key' => '/etc/puppetlabs/puppet/eyaml/public_key.pkcs7.pem'
}
In your function’s signature, you can validate the options hash by using
      the Struct data type to restrict its contents. In particular, note you can disable all of the
        path, paths, glob, and globs settings for your backend by disallowing the path key in the options hash.
For more information, see the Struct data
      type.


Related information
configure_merge_behavior_hiera.html
Configuring a hierarchy level: hiera-eyaml
Interpolation


The Puppet::LookupContext object and methods 

To support caching and other backends needs, Hiera provides a Puppet::LookupContext object.
In Ruby
        functions, the context object is a normal Ruby object of
        class Puppet::LookupContext, and you can
        call methods with standard Ruby syntax, for example context.not_found.
In
          Puppet language functions, the context object appears as
        the special data type Puppet::LookupContext, that has methods attached.You can call the context’s
        methods using Puppet’s chained function call syntax with the
        method name instead of a normal function call syntax, for example, $context.not_found. For methods that take a block, use Puppet’s lambda syntax (parameters outside block) instead of
          Ruby’s block syntax (parameters inside
      block).

not_found()

Tells Hiera to halt this lookup and move on to the next data
        source. Call this method when your function cannot find a matching key or a given lookup.
        This method returns no value.
For data_hash backends, return an empty hash. The empty hash results in
          not_found, and prevents further calls to the provider. Missing data
        sources are not an issue when using path, paths, glob, or globs, but are important for backends that locate their own data sources.
For lookup_key and data_dig backends, use
          not_found when a requested key is not present in the data source or the
        data source does not exist. Do not return undef or nil for
        missing keys, as these are legal values that can be set in data.


interpolate(value) 

Returns the provided value, but with any Hiera interpolation
        tokens (%{variable} or %{lookup('key')}) replaced by their
        value. This lets you opt-in to allowing Hiera-style
        interpolation in your backend’s data sources. It works recursively on arrays and hashes.
        Hashes can interpolate into both keys and values.
In data_hash backends, support for interpolation is built in, and you do
        not need to call this method.
In lookup_key and data_dig backends, call this method if
        you want to support interpolation.


environment_name() 

Returns the name of the environment, regardless of layer.


module_name() 

Returns the name of the module whose hiera.yaml called the function.
        Returns undef (in Puppet) or
          nil (in Ruby) if the function was called
        by the global or environment layer.


cache(key, value) 

Caches a value, in a per-data-source private cache. It also returns the cached value.
On future lookups in this data source, you can retrieve values by calling
          cached_value(key). Cached values are immutable, but you can replace the
        value for an existing key. Cache keys can be anything valid as a key for a Ruby hash, including nil.
For example, on its first invocation for a given YAML file, the built-in
          eyaml_lookup_key backend reads the whole file and caches it, and then
        decrypts only the specific value that was requested. On subsequent lookups into that file,
        it gets the encrypted value from the cache instead of reading the file from disk again. It
        also caches decrypted values so that it won’t have to decrypt again if the same key is
        looked up repeatedly.
The cache is useful for storing session keys or connection objects for backends that access
        a network service.
Each Puppet::LookupContext cache lasts for the duration of the current
        catalog compilation. A node can’t access values cached for a previous node.

Hiera creates a separate cache for each combination of inputs
        for a function call, including inputs like name that are configured in
          hiera.yaml but not passed to the function. Each hierarchy level has its
        own cache, and hierarchy levels that use multiple paths have a separate cache for each
        path.
If any inputs to a function change, for example, a path interpolates a local variable whose
        value changes between lookups, Hiera uses a fresh cache.


cache_all(hash) 

Caches all the key-value pairs from a given hash. Returns undef (in Puppet) or nil (in Ruby).


cached_value(key) 

Returns a previously cached value from the per-data-source private cache. Returns
          undef or nil if no value with this name has been
        cached.


cache_has_key(key) 

Checks whether the cache has a value for a given key yet. Returns true or
          false.


cached_entries() 

Returns everything in the per-data-source cache as an iterable object. The
        returned object is not a hash. If you want a hash, use
          Hash($context.all_cached()) in the Puppet
        language or Hash[context.all_cached()] in Ruby.


cached_file_data(path) 


Puppet syntax:

cached_file_data(path) |content| { ... }


Ruby syntax:

cached_file_data(path) {|content| ...}

For best performance, use this method to read files in Hiera
        backends.

cached_file_data(path) {|content| ...} returns the content of the specified
        file as a string. If an optional block is provided, it passes the content to the block and
        returns the block’s return value. For example, the built-in JSON backend uses a block to
        parse JSON and return a hash:
        context.cached_file_data(path) do |content|
      begin
        JSON.parse(content)
      rescue JSON::ParserError => ex
        # Filename not included in message, so we add it here.
        raise Puppet::DataBinding::LookupError, "Unable to parse (#{path}): #{ex.message}"
      end
    end

On repeated access to a given file, Hiera checks whether the
        file has changed on disk. If it hasn’t, Hiera uses cached
        data instead of reading and parsing the file again.
This method does not use the same per-data-source caches as
          cache(key, value) and similar methods. It uses a separate cache that
        lasts across multiple catalog compilations, and is tied to Puppet Server’s environment cache.
Because the cache can outlive a given node’s catalog compilation, do not do any
        node-specific pre-processing (like calling context.interpolate) in this
        method’s block.


explain() { ‘message’ }


Puppet syntax:

explain() || { 'message' }


Ruby syntax:

explain() { 'message' }

In both Puppet and Ruby, the
        provided block must take zero arguments.

explain() { 'message' } adds a message, which appears in
        debug messages or when using puppet lookup --explain. The block provided to this function
        must return a string.
The explain method is useful for complex lookups where a function tries several different
        things before arriving at the value. The built-in backends do not use the explain method,
        and they still have relatively verbose explanations. This method is for when you need to
        provide even more detail.

Hiera never executes the explain block unless explain is
        enabled.


 




          Was this page helpful?
        
Yes
No







              Don’t fill this out if you’re human: 






Thank you for your feedback!

            Feel free to add a comment or suggestion.
            





Send
Please enter your feedback





              Don’t fill this out if you’re human: 







            We’re sorry to hear that! 
            Please tell us why so we can help.
          

            Enter your feedback and email. This form is sent to the Puppet docs team.
            We ask for your email as we might contact you regarding your feedback.
          

            If you need help with the product itself, visit Puppet Support
            or ask in Puppet Community on Slack.
          

            Feedback:
            






            Email Address:
            






            To learn about how Puppet uses your personal information,
            visit our privacy policy.
          


Send
Please enter your feedback and contact email

          If you leave us your email, we may contact you regarding your feedback.
          For more information on how Puppet uses your personal information, see
          our
          privacy policy.
        





            Don’t fill this out if you’re human: 








    See an issue? Please file a JIRA ticket in our
    [DOCUMENTATION]
      project.
  











Puppet by Perforce gives IT operations teams back their time and offers peace of mind with infrastructure automation that enables security and compliance.






Legal
Privacy Policy
Terms of Use
Security


©  Puppet, Inc., a Perforce company. All rights reserved.




Puppet and other identified trademarks are the property of Puppet, Inc., Perforce Software, Inc., or an affiliate. Such trademarks are claimed and/or registered in the U.S. and other countries and regions. All third-party trademarks are the property of their respective holders. References to third-party trademarks do not imply endorsement or sponsorship of any products or services by the trademark holder. Contact Puppet, Inc., for further details.

