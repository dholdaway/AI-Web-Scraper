Title: Type development
URL: https://www.puppet.com/docs/puppet/7/custom_types

Puppet.com
Forge
Education


                                    Try Puppet
                                


































        Docs
        






Products
Puppet Enterprise
Open Source Puppet
Bolt
Security Compliance Management
Continuous Delivery
Puppet Development Kit
Puppet DB
Puppet Plugin for VMware



        Support
        






Get
Technical Support Plans
Support Lifecycle Policy
New Puppet Enterprise Customer?



        Community
        






About Puppet
Company
Developer Experience
Community
Puppet Champions
Puppet Test Pilots
Community Calendar
Slack Channel







 









































PRODUCT AND VERSION


      Current product
      










      Current version
      








Puppet  7.34.0

Release notes

Puppet release notes
Puppet  7.34.0Security


Puppet known issues
Puppet Server release notes
Puppet Server known Issues
PuppetDB release notes (link)

Facter release notes
Facter 4.10.0
Facter 4.9.0
Facter 4.8.0
Facter 4.7.1
Facter 4.7.0
Facter 4.6.1
Facter 4.6.0
Facter 4.5.2


Facter known issues
What's new since Puppet 6?
Upgrading from Puppet 6 to Puppet 7

Experimental featuresMsgpack support

Archived documentation



Puppet overview
What is Puppet?
Why use Puppet desired state management?
Key concepts behind Puppet
The Puppet platform 
Puppet platform lifecycle 
Open source Puppet vs Puppet Enterprise (PE)
The Puppet ecosystem
Use cases
Glossary
Navigating the documentation



Set up Puppet

Install Puppet
System requirements
Installing Puppet  
Installing and configuring agents
Manually verify packages
Managing Platform versions



Configure Puppet settings
Puppet settings
Key configuration settings

Puppet's configuration files
puppet.conf: The main config file
environment.conf: Per-environment settings
fileserver.conf: Custom fileserver mount points
puppetdb.conf: PuppetDB server locations
autosign.conf: Basic certificate autosigning 
csr_attributes.yaml: Certificate extensions 
custom_trusted_oid_mapping.yaml: Short names for cert extension OIDs
device.conf: Network hardware access
routes.yaml: Advanced plugin routing


Adding file server mount points
Checking the values of settings
Editing settings on the command line
Configuration Reference



Upgrading
Upgrade Puppet Server

Upgrade agents
Upgrade agents using the puppet_agent module
Upgrade *nix agents
Upgrade Windows agents
Upgrade macOS agents


Upgrade PuppetDB



Environments
About environments
Creating environments
Environment isolation



Directories and files
Code and data directory (codedir)
Config directory (confdir)
Main manifest directory
The modulepath
SSL directory (ssldir)
Cache directory (vardir)


Report reference



Platform components

Puppet Server
About Puppet Server
Deprecated features
Server and agent compatibility
Installing Puppet Server

Configuring Puppet Server
Configuring Puppet Server

Puppet Server configuration files
auth.conf
ca.conf
global.conf
logback.xml
metrics.conf
product.conf
puppetserver.conf
web-routes.conf
webserver.conf


Migrating to the HOCON auth.conf format
Advanced logging configuration
Differing behavior in puppet.conf



Using and extending Puppet Server
Subcommands
Using Ruby gems
Intermediate CA
Infrastructure certificate revocation list (CRL)
External SSL termination

Server metrics
Monitoring Puppet Server metrics
HTTP Client Metrics


Tuning guide
Applying metrics to improve performance
Submitting usage telemetry
Scaling Puppet Server
Restarting Puppet Server"



Developer information
Developer debugging
Running from source
Tracing code events



Puppet Server HTTP API
Puppet Server HTTP API overview
PSON

Puppet v3 API
Catalog
Node
Facts
File Bucket File
File Content
File Metadata
Report



Puppet v4 APICatalog API


CA v1 API
Certificate
Certificate Request
Certificate Status
Certificate Revocation List
Expirations
Certificate Clean


Schemas (JSON)



API endpoints

Metrics API endpoints
v1 metrics
v2 (Jolokia) metrics



Status API endpoints
Services endpoint
Simple endpoint



Administrative API endpoints
Environment cache
JRuby pool



Server-specific Puppet API endpoints
Environment classes
Environment modules
Static file content





Certificate authority and SSL
Puppet Server CA commands
Intermediate CA
Autosigning certificate requests
CSR attributes and certificate extensions
Regenerating certificates in a Puppet deployment
External CA
External SSL termination





Facter  
Facter: CLI
Facter: Core Facts

Custom facts overviewEnvironment facts 

Writing custom facts
External facts
Configuring Facter with facter.conf


PuppetDB

Puppet services and tools
Puppet commands
Running Puppet commands on Windows  

primary Puppet serverAbout Puppet Server

Puppet agent on *nix systems
Puppet agent on Windows
Puppet apply
Puppet device



Puppet reports
Reporting
Report reference
Writing custom report processors
Report format



Life cycle of a Puppet run
Agent-server HTTPS communications
Catalog compilation
Static catalogs 





Using Puppet code
Classifying nodes
Managing environment content with a Puppetfile
Using content from Puppet Forge

Designing system configs (roles and profiles)
The roles and profiles method 
Roles and profiles example 
Designing advanced profiles 
Designing convenient roles 



Separating data (Hiera)
About Hiera  
Getting started with Hiera  
Configuring Hiera
Creating and editing data 
Looking up data with Hiera  
Writing new data backends 

Debugging Hiera
Unexpected values
Common errors


Upgrading to Hiera 5 



Use case examples
Manage NTP
Manage sudo 
Manage DNS
Manage firewall rules
Forge examples





Syntax and settings

The Puppet language
Puppet language overview
Puppet language syntax examples
The Puppet language style guide 
Files and paths on Windows  
Code comments 
Variables
Resources

Resource types
Resource Type Reference (Single-Page)
Built-in types
Optional resource types for Windows
Resource Type: exec
Using exec on Windows  
Resource Type: file
Using file on Windows
Resource Type: filebucket
Resource Type: group
Using user and group on Windows
Resource types overview
Resource Type: notify
Resource Type: package
Using package on Windows  
Resource Type: resources
Resource Type: schedule
Resource Type: service
Using service
Resource Type: stage
Resource Type: tidy
Resource Type: user


Relationships and ordering
Classes
Defined resource types
Bolt tasks
Expressions and operators
Conditional statements and expressions
Function calls
Built-in function reference
Node definitions

Facts and built-in variables
Accessing facts from Puppet code
Built-in variables


Reserved words and acceptable names

Custom resources

Develop types and providers with the Resource APIResource API reference


Low-level method for developing types and providers
Type development
Provider development
Creating resources





Custom functions
Custom functions overview 
Writing custom functions in the Puppet language

Writing custom functions in Ruby
Custom functions in Ruby overview
Ruby function signatures
Using special features in implementation methods
Iterative functions
Refactoring legacy 3.x functions



Deferring a function
Deferred functions overview
Using a template with Deferred values
Write a deferred function to store secrets
Integrations with secret stores





Values, data types, and aliases
Type aliases
Typecasting
Abstract data types
Arrays
Binary
Booleans
Data type syntax
Default
Error data type
Hashes
Numbers
Regular expressions
Resource and class references
Resource types
Sensitive
Strings
Time-related data types
Undef



Templates
Creating templates using Embedded Puppet
Creating templates using Embedded Ruby



Advanced constructs
Iteration and loops
Lambdas
Resource default statements
Resource collectors
Virtual resources
Exported resources
Tags
Run stages



Details of complex behaviors
Containment
Scope
Namespaces and autoloading


Securing sensitive data


Metaparameter reference
Configuration Reference
Built-in function reference

Puppet Man Pages

Core tools
Man Page: puppet agent
Man Page: puppet apply
Man Page: puppet module
Man Page: puppet resource
Man Page: puppet lookup



Occasionally useful
Man Page: puppet config
Man Page: puppet describe
Man Page: puppet device
Man Page: puppet doc
Man Page: puppet help
Man Page: puppet node
Man Page: puppet parser



Niche
Man Page: puppet catalog
Man Page: puppet facts
Man Page: puppet filebucket
Man Page: puppet report







Developing modules

Modules
Modules overview
Plug-ins in modules
Module cheat sheet
Installing and managing modules from the command line
Beginner's guide to writing modules
Module metadata
Documenting modules
Documenting modules with Puppet Strings  
Puppet Strings style guide

Publishing modulesUsing the Forge API

Contributing to Puppet modules


Puppet Development Kit (PDK)
Puppet VSCode extension

PowerShell DSC Resources
Converting DSC Resources
Distributing arbitrary DSC resources
Upgrading Puppet DSC modules 
Troubleshooting DSC Resources 


Ruby API for developing extensions


Type development

When you define a resource type, focus on what the resource
    can do, not how it does it.

Note: Unless you are maintaining
        existing type and provider code, or the Resource API limitations affect you, use the
        Resource API to create custom resource types, instead of this method.
Creating types
Types are created by calling the newtype method
        on the Puppet::Type class:# lib/puppet/type/database.rb
Puppet::Type.newtype(:database) do
  @doc = "Create a new database."
  # ... the code ...
endThe name of the type is the only required argument to newtype. The name must be a  Ruby symbol, and the name of the file containing the
        type must match the type's name.
The newtype method also requires a block of
        code, specified with either curly braces ({ ... }) or
          the do ... end syntax. The code block implements
        the type, and contains all of the properties and parameters. The block will not be passed
        any arguments.
You can optionally specify a self-refresh option for the type by putting :self_refresh => true after the name. Doing so causes resources
        of this type to refresh (as if they had received an event through a
        notify-subscribe relationship) whenever a change is made to the resource. A notable use of
        this option is in the core mount type.




Documenting types

Write a description for the custom resource type in the
    type's @doc instance variable.
    The description can be extracted by the puppet doc --reference type command, which generates a complete
    type reference which includes your new type, and by the puppet describe command, which outputs information about
    specific types.
Write the description as a string in
        standard Markdown format. When the Puppet tools
        extract the string, they strip the greatest common amount of leading whitespace from the
        front of each line, excluding the first line. For
        example:Puppet::Type.newtype(:database) do
  @doc = %q{Creates a new database. Depending
    on the provider, this might create relational
    databases or NoSQL document stores.

    Example:

        database {'mydatabase':
          ensure => present,
          owner  => root,
        }
  }
endIn
        this example, any whitespace would be trimmed from the first line (in this case, it’s zero
        spaces), then the greatest common amount would be trimmed from remaining lines. Three lines
        have four leading spaces, two lines have six, and two lines have eight, so four leading
        spaces would be trimmed from each line. This leaves the example code block indented by four
        spaces, and thus doesn’t break the Markdown formatting.


Properties and parameters

The bulk of a type definition consists
        of properties and parameters, which become the resource attributes available
        when declaring a resource of the new type.
The difference between a property
                and a parameter is subtle but important: 
Properties correspond to something measurable on the
                        target system. For example, the UID and GID of a user account are
                        properties, because their current state can be queried or changed. In
                        practical terms, setting a value for a property causes a method to be called
                        on the provider.

Parameters change how Puppet manages a resource, but do not
                            necessarily map directly to something measurable. For example,
                                the user type’s managehome attribute is a
                            parameter — its value affects what Puppet
                            does, but the question of whether Puppet
                            is managing a home directory isn’t an innate property of the user
                            account.



Additionally, there are a few special attributes
                    called metaparameters, which are supported by all resource types.
                These don’t need to be handled when creating new types; they’re implemented
                elsewhere.
A type definition typically has multiple
                properties, and must have at least one parameter.


Properties

A custom type's properties are at the heart of defining how
    the resource works. In most cases, it’s the properties that interact with your resource’s
    providers.
If you define a property named owner, then when you are
        retrieving the state of your resource, then the owner property calls the owner method on the provider. In turn, when you are setting the
        state (because the resource is out of sync), then the owner property calls the owner= method to set the state on disk.
There’s one common exception to this: The ensure property is special because it’s used to create and destroy
        resources. You can set this property up on your resource type just by calling the ensurable method in your type
        definition:Puppet::Type.newtype(:database) do
  ensurable
  ...
endThis
        property uses three methods on the provider: create, destroy, and exists?. The last method, somewhat obviously, is a Boolean to determine if the
        resource exists. If a resource’s ensure property is out of sync, then no other properties are checked or
        modified.
You can modify how ensure behaves, such as by adding other valid values and
        determining what methods get called as a result; see types like package for examples.
The
        rest of the properties are defined a lot like you define the types, with the newproperty method, which should
        be called on the
        type:Puppet::Type.newtype(:database) do
  ensurable
  newproperty(:owner) do
    desc "The owner of the database."
    ...
  end
endNote
        the call to desc; this sets
        the documentation string for this property, and for Puppet
        types that get distributed with Puppet, it is extracted as
        part of the Type reference.
When Puppet was first developed, there would typically be a lot of
        code in this property definition. Now, however, you only define valid values or set up
        validation and munging. If you specify valid values, then Puppet only accepts those values, and automatically handles
        accepting either strings or symbols. In most cases, you only define allowed values for
          ensure, but it works for
        other properties,
        too:newproperty(:enable) do
  newvalue(:true)
  newvalue(:false)
endYou
        can attach code to the value definitions (this code would be called instead of the property= method), but it’s
        normally unnecessary.
For most properties, though, it is sufficient
        to set up
        validation:newproperty(:owner) do
  validate do |value|
    unless value =~ /^\w+/
      raise ArgumentError, "%s is not a valid user name" % value
    end
  end
endNote
        that the order in which you define your properties can be important: Puppet keeps track of the definition order, and it always
        checks and fixes properties in the order they are defined.
Customizing behavior
By default, if a property is assigned multiple values in an array:

It is considered in sync if any of those values matches the current value.


If none of those values match, the first one is used when syncing the property.



If, instead, the property should only be in sync if all values match the current
        value (for example, a list of times in a cron job), declare
        this:newproperty(:minute, :array_matching => :all) do # :array_matching defaults to :first
  ...
end

You can also customize how information about your property gets logged. You can create
          an is_to_s method to change how the current values
        are described, should_to_s to change how the
        desired values are logged, and change_to_s to
        change the overall log message for changes. See current types for examples.

Handling property values
When a resource is created with a list of desired values, those values are stored in each
        property in its @should instance variable. You can retrieve
        those values directly by calling should on your resource
        (although note that when :array_matching is set
          to :first you get the first value in the array;
        otherwise you get the whole
        array):myval = should(:color)When
        you’re not sure (or don’t care) whether you’re dealing with a property or parameter, it’s
        best to use value:myvalue = value(:color)




Parameters

Parameters are defined the same way as properties. The
    difference between them is that parameters never result in methods being called on
    providers.
To define a new parameter, call
          the newparam method. This method takes the name of the parameter (as a symbol) as
        its argument, as well as a block of code. You can and should provide documentation for each
        parameter by calling the desc method inside its block. Tools that generate docs from this
        description trim leading whitespace from multiline strings, as described for type
        descriptions.newparam(:name) do
  desc "The name of the database."
end

Namevar
Every type must have at least one mandatory parameter: the namevar. This parameter uniquely
        identifies each resource of the type on the target system — for example, the path of a file
        on disk, the name of a user account, or the name of a package.
If the user doesn’t specify a value for the namevar when declaring a resource, its value
        defaults to the title of the resource.
There are three ways to designate a namevar. Every type must have exactly
        one parameter that meets exactly one of these criteria:

Create a parameter whose name is :name. Because
              most types just use :name as the namevar, it
              gets special treatment and automatically becomes the
              namevar.newparam(:name) do
  desc "The name of the database."
end



Provide the :namevar => true option as
              an additional argument to the newparam call.
              This allows you to use a namevar with a different, more descriptive name, such as
                the file type’s path parameter.newparam(:path, :namevar => true) do
  ...
end



Call the isnamevar method (which takes no
              arguments) inside the parameter’s code block. This allows you to use a namevar with a
              different, more descriptive name. There is no practical difference between this and
              option 2.newparam(:path) do
  isnamevar
  ...
end





Specifying allowed values
If your parameter has a fixed list of valid values, you can declare them all at the same
        time:newparam(:color) do
  newvalues(:red, :green, :blue, :purple)
endYou can specify regular expressions in addition to literal values; matches
        against regex always happen after equality comparisons against literal values, and those
        matches are not converted to symbols. For instance, given the following
        definition:newparam(:color) do
  desc "Your color, and stuff."

  newvalues(:blue, :red, /.+/)
endIf you provide blue as the value, then your parameter is set to :blue, but if you provide green, then it is set to "green".

Validation and munging
If your parameter does not have a defined list of values, or you need to convert the values
        in some way, you can use the validate and munge
        hooks:newparam(:color) do
  desc "Your color, and stuff."

  newvalues(:blue, :red, /.+/)

  validate do |value|
    if value == "green"
      raise ArgumentError,
        "Everyone knows green databases don't have enough RAM"
    else
      super(value)
    end
  end

  munge do |value|
    case value
    when :mauve, :violet # are these colors really any different?
      :purple
    else
      super(value)
    end
  end
endThe default validate method looks for values
        defined using newvalues and if there are any values defined
        it accepts only those values (this is how allowed values are validated). The default munge method converts any values that are specifically allowed
        into symbols. If you override either of these methods, note that you lose this value
        handling and symbol conversion, which you’ll have to call super for.
Values are always validated before they’re munged.
Lastly, validation and munging only happen when a value is assigned. They have no
        role to play at all during use of a given value, only during assignment.

Boolean parameters
Boolean parameters are common. To avoid repetition, some utilities are
        available:require 'puppet/parameter/boolean'
# ...
newparam(:force, :boolean => true, :parent => Puppet::Parameter::Boolean)There
        are two parts here. The :parent =>
          Puppet::Parameter::Boolean part configures the parameter to accept lots of
        names for true and false, to make things easy for your users. The :boolean => true creates a boolean method on the type class to return the value of the parameter. In this
        example, the method would be named force?.



Automatic relationships

Use automatic relationships to define the ordering of resources.

By default, Puppet includes and processes
        resources in the order they are defined in their manifest. However, there are times when
        resources need to be applied in a different order. The Puppet
        language provides ways to express explicit ordering such as relationship metaparameters
          (require, before, etc),
        chaining arrows and the require and contain functions.
Sometimes there is natural relationship between your custom type and other
        resource types. For example, ssh authorized keys can only be managed after you create the
        home directory and you can only manage files after you create their parent directories. You
        can add explicit relationships for these, but doing so can be restrictive for others who may
        want to use your custom type. Automatic relationships provide a way to define implicit
        ordering. For example, to automatically add a require
        relationship from your custom type to a configuration file that it depends on, add the
        following to your custom
        type:autorequire(:file) do
  ['/path/to/file']
end

The Ruby symbol :file refers to the type of resource you want to require, and the array contains resource title(s) with which to create the
          require relationship(s). The effect is nearly equivalent
        to using an explicit require
        relationship:custom { <CUSTOM RESOURCE>:
  ensure => present,
  require => File['/path/to/file']
}

An important difference between automatic and explicit relationships is that
        automatic relationships do not require the other resources to exist, while explicit
        relationships do.



Agent-side pre-run resource validation

A resource can have prerequisites on the target, without
    which it cannot be synced. In some cases, if the absence of these prerequisites would be
    catastrophic, you might want to halt the catalog run if you detect a missing
    prerequisite.
In this situation, define a method in
        your type named pre_run_check. This method can do any check you want. It should take no
        arguments, and should raise a Puppet::Error if the catalog run should be halted.
If a type has a pre_run_check method, Puppet agent and
          puppet apply runs the
        check for every resource of the type before attempting to apply the catalog. It collects any
        errors raised, and presents all of them before halting the catalog run.
As a trivial example, here’s a pre-run check that fails randomly, about one time
        out of
        six:Puppet::Type.newtype(:thing) do
  newparam :name, :namevar => true

  def pre_run_check
    if(rand(6) == 0)
      raise Puppet::Error, "Puppet roulette failed, no catalog for you!"
    end
  end
end



How types and providers interact

The type definition declares the features that a provider
    must have and what’s required to make them work. Providers can either be tested for whether they
    suffice, or they can declare that they have the features. Because a type's properties call
    getter and setter methods on the providers, the providers must define getters and setters for
    each property (except ensure).
Additionally, individual properties and
        parameters in the type can declare that they require one or more specific features, and Puppet throws an error if those parameters are used with
        providers missing those
        features:newtype(:coloring) do
  feature :paint, "The ability to paint.", :methods => [:paint]
  feature :draw, "The ability to draw."

  newparam(:color, :required_features => %w{paint}) do
    ...
  end
endThe
        first argument to the feature method is the name of the feature, the second argument is its
        description, and after that is a hash of options that help Puppet determine whether the feature is available. The only
        option currently supported is specifying one or more methods that must be defined on the
        provider. If no methods are specified, then the provider needs to specifically declare that
        it has that
        feature:Puppet::Type.type(:coloring).provide(:drawer) do
  has_feature :draw
endThe
        provider can specify multiple available features at the same time with has_features.
When
        you define features on your type, Puppet automatically
        defines the following class methods on the provider:

feature?: Passed a
            feature name, returns true if the feature is available or false otherwise.

features: Returns a list
            of all supported features on the provider.

satisfies?: Passed a
            list of feature, returns true if they are all available, false otherwise.


Additionally, each feature gets a separate Boolean method, so the
        above example would result in a paint? method on the provider.


Related informationProvider development
 




          Was this page helpful?
        
Yes
No







              Don’t fill this out if you’re human: 






Thank you for your feedback!

            Feel free to add a comment or suggestion.
            





Send
Please enter your feedback





              Don’t fill this out if you’re human: 







            We’re sorry to hear that! 
            Please tell us why so we can help.
          

            Enter your feedback and email. This form is sent to the Puppet docs team.
            We ask for your email as we might contact you regarding your feedback.
          

            If you need help with the product itself, visit Puppet Support
            or ask in Puppet Community on Slack.
          

            Feedback:
            






            Email Address:
            






            To learn about how Puppet uses your personal information,
            visit our privacy policy.
          


Send
Please enter your feedback and contact email

          If you leave us your email, we may contact you regarding your feedback.
          For more information on how Puppet uses your personal information, see
          our
          privacy policy.
        





            Don’t fill this out if you’re human: 








    See an issue? Please file a JIRA ticket in our
    [DOCUMENTATION]
      project.
  











Puppet by Perforce gives IT operations teams back their time and offers peace of mind with infrastructure automation that enables security and compliance.






Legal
Privacy Policy
Terms of Use
Security


©  Puppet, Inc., a Perforce company. All rights reserved.




Puppet and other identified trademarks are the property of Puppet, Inc., Perforce Software, Inc., or an affiliate. Such trademarks are claimed and/or registered in the U.S. and other countries and regions. All third-party trademarks are the property of their respective holders. References to third-party trademarks do not imply endorsement or sponsorship of any products or services by the trademark holder. Contact Puppet, Inc., for further details.

