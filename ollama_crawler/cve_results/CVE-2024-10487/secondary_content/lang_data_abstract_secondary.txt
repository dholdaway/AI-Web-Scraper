Title: Abstract data types
URL: https://www.puppet.com/docs/puppet/7/lang_data_abstract

Puppet.com
Forge
Education


                                    Try Puppet
                                


































        Docs
        






Products
Puppet Enterprise
Open Source Puppet
Bolt
Security Compliance Management
Continuous Delivery
Puppet Development Kit
Puppet DB
Puppet Plugin for VMware



        Support
        






Get
Technical Support Plans
Support Lifecycle Policy
New Puppet Enterprise Customer?



        Community
        






About Puppet
Company
Developer Experience
Community
Puppet Champions
Puppet Test Pilots
Community Calendar
Slack Channel







 









































PRODUCT AND VERSION


      Current product
      










      Current version
      








Puppet  7.34.0

Release notes

Puppet release notes
Puppet  7.34.0Security


Puppet known issues
Puppet Server release notes
Puppet Server known Issues
PuppetDB release notes (link)

Facter release notes
Facter 4.10.0
Facter 4.9.0
Facter 4.8.0
Facter 4.7.1
Facter 4.7.0
Facter 4.6.1
Facter 4.6.0
Facter 4.5.2


Facter known issues
What's new since Puppet 6?
Upgrading from Puppet 6 to Puppet 7

Experimental featuresMsgpack support

Archived documentation



Puppet overview
What is Puppet?
Why use Puppet desired state management?
Key concepts behind Puppet
The Puppet platform 
Puppet platform lifecycle 
Open source Puppet vs Puppet Enterprise (PE)
The Puppet ecosystem
Use cases
Glossary
Navigating the documentation



Set up Puppet

Install Puppet
System requirements
Installing Puppet  
Installing and configuring agents
Manually verify packages
Managing Platform versions



Configure Puppet settings
Puppet settings
Key configuration settings

Puppet's configuration files
puppet.conf: The main config file
environment.conf: Per-environment settings
fileserver.conf: Custom fileserver mount points
puppetdb.conf: PuppetDB server locations
autosign.conf: Basic certificate autosigning 
csr_attributes.yaml: Certificate extensions 
custom_trusted_oid_mapping.yaml: Short names for cert extension OIDs
device.conf: Network hardware access
routes.yaml: Advanced plugin routing


Adding file server mount points
Checking the values of settings
Editing settings on the command line
Configuration Reference



Upgrading
Upgrade Puppet Server

Upgrade agents
Upgrade agents using the puppet_agent module
Upgrade *nix agents
Upgrade Windows agents
Upgrade macOS agents


Upgrade PuppetDB



Environments
About environments
Creating environments
Environment isolation



Directories and files
Code and data directory (codedir)
Config directory (confdir)
Main manifest directory
The modulepath
SSL directory (ssldir)
Cache directory (vardir)


Report reference



Platform components

Puppet Server
About Puppet Server
Deprecated features
Server and agent compatibility
Installing Puppet Server

Configuring Puppet Server
Configuring Puppet Server

Puppet Server configuration files
auth.conf
ca.conf
global.conf
logback.xml
metrics.conf
product.conf
puppetserver.conf
web-routes.conf
webserver.conf


Migrating to the HOCON auth.conf format
Advanced logging configuration
Differing behavior in puppet.conf



Using and extending Puppet Server
Subcommands
Using Ruby gems
Intermediate CA
Infrastructure certificate revocation list (CRL)
External SSL termination

Server metrics
Monitoring Puppet Server metrics
HTTP Client Metrics


Tuning guide
Applying metrics to improve performance
Submitting usage telemetry
Scaling Puppet Server
Restarting Puppet Server"



Developer information
Developer debugging
Running from source
Tracing code events



Puppet Server HTTP API
Puppet Server HTTP API overview
PSON

Puppet v3 API
Catalog
Node
Facts
File Bucket File
File Content
File Metadata
Report



Puppet v4 APICatalog API


CA v1 API
Certificate
Certificate Request
Certificate Status
Certificate Revocation List
Expirations
Certificate Clean


Schemas (JSON)



API endpoints

Metrics API endpoints
v1 metrics
v2 (Jolokia) metrics



Status API endpoints
Services endpoint
Simple endpoint



Administrative API endpoints
Environment cache
JRuby pool



Server-specific Puppet API endpoints
Environment classes
Environment modules
Static file content





Certificate authority and SSL
Puppet Server CA commands
Intermediate CA
Autosigning certificate requests
CSR attributes and certificate extensions
Regenerating certificates in a Puppet deployment
External CA
External SSL termination





Facter  
Facter: CLI
Facter: Core Facts

Custom facts overviewEnvironment facts 

Writing custom facts
External facts
Configuring Facter with facter.conf


PuppetDB

Puppet services and tools
Puppet commands
Running Puppet commands on Windows  

primary Puppet serverAbout Puppet Server

Puppet agent on *nix systems
Puppet agent on Windows
Puppet apply
Puppet device



Puppet reports
Reporting
Report reference
Writing custom report processors
Report format



Life cycle of a Puppet run
Agent-server HTTPS communications
Catalog compilation
Static catalogs 





Using Puppet code
Classifying nodes
Managing environment content with a Puppetfile
Using content from Puppet Forge

Designing system configs (roles and profiles)
The roles and profiles method 
Roles and profiles example 
Designing advanced profiles 
Designing convenient roles 



Separating data (Hiera)
About Hiera  
Getting started with Hiera  
Configuring Hiera
Creating and editing data 
Looking up data with Hiera  
Writing new data backends 

Debugging Hiera
Unexpected values
Common errors


Upgrading to Hiera 5 



Use case examples
Manage NTP
Manage sudo 
Manage DNS
Manage firewall rules
Forge examples





Syntax and settings

The Puppet language
Puppet language overview
Puppet language syntax examples
The Puppet language style guide 
Files and paths on Windows  
Code comments 
Variables
Resources

Resource types
Resource Type Reference (Single-Page)
Built-in types
Optional resource types for Windows
Resource Type: exec
Using exec on Windows  
Resource Type: file
Using file on Windows
Resource Type: filebucket
Resource Type: group
Using user and group on Windows
Resource types overview
Resource Type: notify
Resource Type: package
Using package on Windows  
Resource Type: resources
Resource Type: schedule
Resource Type: service
Using service
Resource Type: stage
Resource Type: tidy
Resource Type: user


Relationships and ordering
Classes
Defined resource types
Bolt tasks
Expressions and operators
Conditional statements and expressions
Function calls
Built-in function reference
Node definitions

Facts and built-in variables
Accessing facts from Puppet code
Built-in variables


Reserved words and acceptable names

Custom resources

Develop types and providers with the Resource APIResource API reference


Low-level method for developing types and providers
Type development
Provider development
Creating resources





Custom functions
Custom functions overview 
Writing custom functions in the Puppet language

Writing custom functions in Ruby
Custom functions in Ruby overview
Ruby function signatures
Using special features in implementation methods
Iterative functions
Refactoring legacy 3.x functions



Deferring a function
Deferred functions overview
Using a template with Deferred values
Write a deferred function to store secrets
Integrations with secret stores





Values, data types, and aliases
Type aliases
Typecasting
Abstract data types
Arrays
Binary
Booleans
Data type syntax
Default
Error data type
Hashes
Numbers
Regular expressions
Resource and class references
Resource types
Sensitive
Strings
Time-related data types
Undef



Templates
Creating templates using Embedded Puppet
Creating templates using Embedded Ruby



Advanced constructs
Iteration and loops
Lambdas
Resource default statements
Resource collectors
Virtual resources
Exported resources
Tags
Run stages



Details of complex behaviors
Containment
Scope
Namespaces and autoloading


Securing sensitive data


Metaparameter reference
Configuration Reference
Built-in function reference

Puppet Man Pages

Core tools
Man Page: puppet agent
Man Page: puppet apply
Man Page: puppet module
Man Page: puppet resource
Man Page: puppet lookup



Occasionally useful
Man Page: puppet config
Man Page: puppet describe
Man Page: puppet device
Man Page: puppet doc
Man Page: puppet help
Man Page: puppet node
Man Page: puppet parser



Niche
Man Page: puppet catalog
Man Page: puppet facts
Man Page: puppet filebucket
Man Page: puppet report







Developing modules

Modules
Modules overview
Plug-ins in modules
Module cheat sheet
Installing and managing modules from the command line
Beginner's guide to writing modules
Module metadata
Documenting modules
Documenting modules with Puppet Strings  
Puppet Strings style guide

Publishing modulesUsing the Forge API

Contributing to Puppet modules


Puppet Development Kit (PDK)
Puppet VSCode extension

PowerShell DSC Resources
Converting DSC Resources
Distributing arbitrary DSC resources
Upgrading Puppet DSC modules 
Troubleshooting DSC Resources 


Ruby API for developing extensions


Abstract data types

If you’re using data types to match or restrict values and
        need more flexibility than what the core data types (such as String or Array) allow, you can use one of the abstract data types to construct a data type that suits your needs and
        matches the values you want.
Each of Puppet's core data types has a
                corresponding value that represents that data type, which can be used to
                match values of that type in several contexts. Each of those core data types only
                match a particular set of values. They let you further restrict the values they’ll
                match, but only in limited ways, and there’s no way to expand the set of values they’ll match. If you need to do
                this, use the corresponding abstract data type.


Related information
Data type syntax
Values, data types, and aliases


Flexible data types

These abstract data types can match values with a variety of concrete data types.
                Some of them are similar to a concrete type but offer alternate ways to restrict
                them (for example, Enum), and some of them let
                you combine types and match a union of what they would individually match (for
                        example, Variant and Optional).
The Optional data type 
The Optional data type
                                        wraps one other data type, and results in a
                                data type that matches anything that type would
                                        match plus
undef. This is useful for matching
                                values that are allowed to be absent. It takes one required
                                parameter.
The full signature for Optional is:Optional[<DATA TYPE>]











Position
Parameter
Data type
Default value
Description




1
Data type

Type or String

none (you must specify a value)
The data type to add undef to. 




If you specify a string "my string" as
                                the parameter, it's equivalent to using Optional[Enum["my string"]] — it matches only
                                that exact string value or undef.

Optional[<DATA TYPE>] is
                                equivalent to Variant[ <DATA
                                        TYPE>, Undef ].
Examples: 

Optional[String]

Matches any string or undef. 

Optional[Array[Integer[0,
                                                  10]]]

Matches an array of integers between 0 and 10,
                                                  or undef.
                                                

Optional["present"]

Matches the exact string "present" or undef. 



The NotUndef data type 
The NotUndef type matches any
                                        value except undef. It can also wrap one other data type, resulting in
                                a type that matches anything the original type would match
                                        except undef. It
                                accepts one optional parameter.
The full signature for NotUndef is:NotUndef[<DATA TYPE>]











Position
Parameter
Data type
Default value
Description




1
Data type

Type or String


Any

The data type to subtract undef from. 




If you specify a string as a parameter for NotUndef, it's equivalent to
                                        writing NotUndef[Enum["my
                                        string"]] — it matches only that exact string
                                value. This doesn’t actually subtract anything, because
                                        the Enum wouldn’t have
                                        matched undef anyway, but it's a convenient notation for
                                mandatory keys in Struct schema hashes.

The Variant data type 
The Variant data type combines
                                any number of other data types, and results in a type that matches
                                the union of what any of those data types would match. It
                                takes any number of parameters, and requires at least one.
The full signature for Variant is:Variant[ <DATA TYPE>, (<DATA TYPE, ...) ]











Position
Parameter
Data type
Default value
Description




1 and up
Data type
Type
none (required)
A data type to add to the resulting
                                                  compound data type. You must provide at least one
                                                  data type parameter, and can provide any number of
                                                  additional ones.




Examples: 

Variant[Integer,
                                                  Float]

Matches any integer or floating point number
                                                  (equivalent to Numeric). 

Variant[Enum['true',
                                                  'false'], Boolean]

matches 'true', 'false', true, or false. 



The Pattern data type 
The Pattern data type only matches strings, but it
                                provides an alternate way to restrict which strings it matches. It
                                takes any number of regular expressions, and results in a data
                                type that matches any strings that would match any of
                                those regular expressions. It takes any number of parameters, and
                                requires at least one.
The full signature for Pattern is:Pattern[ <REGULAR EXPRESSION>, (<REGULAR EXPRESSION>, ...) ]











Position
Parameter
Data type
Default value
Description




1 and up
Regular expression

Regexp

none (required)
A regular expression describing a set of
                                                  strings that the resulting data type matches. You
                                                  must provide at least one regular expression
                                                  parameter, and can provide any number of
                                                  additional ones.




You can use capture groups in the regular expressions, but they won’t
                                cause any variables, like $1, to be set.
Examples: 

Pattern[/\A[a-z].*/]

Matches any string that begins with a lowercase
                                                  letter.

Pattern[/\A[a-z].*/,
                                                  /\ANone\Z/]

Matches the above or the exact
                                                  string None.
                                                



The Enum data type 
The Enum data type only matches strings,
                                but it provides an alternate way to restrict which strings it
                                matches. It takes any number of strings, and results in a data type
                                that matches any string values that exactly match one of those
                                strings. Unlike the == operator,
                                this matching is case-sensitive. It takes any number of parameters,
                                and requires at least one.
The full signature for Enum is:Enum[ <OPTION>, (<OPTION>, ...) ]











Position
Parameter
Data type
Default value
Description




1 and up
Option

String

none (required)
One of the literal string values that the
                                                  resulting data type matches. You must provide at
                                                  least one option parameter, and can provide any
                                                  number of additional ones.




Examples: 

Enum['stopped',
                                                  'running']

Matches the strings 'stopped' and 'running', and no other
                                                  values. 

Enum['true',
                                                  'false']

Matches the strings 'true' and 'false', and no other values. Does not
                                                  match the boolean values true or false (without quotes). 



The Tuple data type 
The Tuple type only matches arrays, but
                                it lets you specify different data types for every element of the
                                array, in order. It takes any number of parameters, and requires at
                                least one.
The full signature for Tuple is:Tuple[ <CONTENT TYPE>, (<CONTENT TYPE>, ..., <MIN SIZE>, <MAX SIZE>) ]











Position
Parameter
Data type
Default value
Description




1 and up
Content type

Type

none (required)
What kind of values the array contains at
                                                  the given position. You must provide at least one
                                                  content type parameter, and can provide any number
                                                  of additional ones.


-2 (second-last)
Minimum size

Integer

number of content types
The minimum number of elements in the
                                                  array. If this is smaller than the number of
                                                  content types you provided, any elements beyond
                                                  the minimum are optional; however, if present,
                                                  they must still match the provided content types.
                                                  This parameter accepts the value default, but this won’t
                                                  use the default value; instead, it means 0 (all
                                                  elements optional). 


-1 (last)
Maximum size

Integer

number of content types

The maximum number of elements in the array.
                                                  You cannot specify a maximum without also
                                                  specifying a minimum. If the maximum is larger
                                                  than the number of content types you provided, it
                                                  means the array can contain any number of
                                                  additional elements, which all must match the last
                                                  content type. This parameter accepts the value
                                                  default, but this
                                                  won’t use the default value; instead, it means
                                                  infinity (any number of elements matching the
                                                  final content type). 
Don't set the maximum smaller than the number
                                                  of content types you provide.





Examples: 

Tuple[String,
                                                  Integer]

Matches a two-element array containing a string
                                                  followed by an integer, like ["hi", 2]. 

Tuple[String, Integer,
                                                  1]

Matches the above or a
                                                  one-element array containing only a string. 

Tuple[String, Integer, 1,
                                                  4]

Matches an array containing one string followed
                                                  by zero to three integers.

Tuple[String, Integer, 1,
                                                  default]

Matches an array containing one string followed
                                                  by any number of integers.



The Struct data type 
The Struct type only
                                matches hashes, but it lets you specify: 

The name of every allowed key. 


Whether each key is required or optional. 


The allowed data type for each of those keys’
                                                  values.



It takes one mandatory parameter.
The full signature for Struct is:Struct[<SCHEMA HASH>]











Position
Parameter
Data type
Default value
Description




1
Schema hash

Hash[Variant[String,
                                                  Optional, NotUndef], Type]

none (required)
A hash that has all of the allowed keys and
                                                  data types for the struct.




A Struct’s schema hash must have the same
                                keys as the hashes it matches. Each value must be a data type that
                                matches the allowed values for that key. 
 The keys in a schema hash are usually strings. They can also be an
                                        Optional or NotUndef type with the key’s name as
                                their parameter. 
If a key is a string, Puppet uses the
                                        value’s type to determine whether it’s optional —
                                because accessing a missing key resolves to the value undef, the key is optional if the
                                value type accepts undef (like
                                        Optional[Array]). 
Note that this doesn’t distinguish between an explicit value of undef and an absent key. If you want
                                to be more explicit, you can use Optional['my_key'] to indicate that a key can be
                                absent, and NotUndef['my_key'] to
                                make it mandatory. If you use one of these, a value type that
                                accepts undef is only used to decide
                                about explicit undef values, not
                                missing keys.
The following example Struct matches
                                hashes like {mode => 'read', path =>
                                        '/etc/fstab'}. Both the mode and path keys
                                are mandatory; mode’s value must be
                                one of 'read', 'write', or 'update', and path
                                must be a string of at least one
                                character:Struct[{mode => Enum[read, write, update],
        path => String[1]}]

The following data type would match the same values as the previous
                                example, but the path key is
                                optional. If present, path must
                                match String[1] or Undef:Struct[{mode => Enum[read, write, update],
        path => Optional[String[1]]}]

In the following data type, the owner key
                                can be absent, but if it’s present, it must be a string; a value of
                                        undef isn’t
                                allowed:Struct[{mode            => Enum[read, write, update],
        path            => Optional[String[1]],
        Optional[owner] => String[1]}]

In the following data type, the owner key is mandatory, but it allows an
                                        explicit undef value:Struct[{mode            => Enum[read, write, update],
        path            => Optional[String[1]],
        NotUndef[owner] => Optional[String[1]]}]


The SemVer data type
A SemVer instance defines a single semantic version or range of
                                versions. For example, "1.2.3" or ">= 1.0.0 < 2.0.0". 
It consists of the following five segments: 

Major version (required)
Minor version (required)
Patch version (required)
Prerelease tag (optional)
Build tag (optional) 

You can create an instance of SemVer from
                                a String, individual values, or a hash of individual values. 
The signatures are: 

type PositiveInteger = Integer[0,default]
type SemVerQualifier = Pattern[/\A(?<part>[0-9A-Za-z-]+)(?:\.\g<part>)*\Z/]
type SemVerString = String[1]
type SemVerHash = Struct[{
  major                =>PositiveInteger,
  minor                =>PositiveInteger,
  patch                =>PositiveInteger,
  Optional[prerelease] =>SemVerQualifier,
  Optional[build]      =>SemVerQualifier
}]

function SemVer.new(SemVerString $str)
function SemVer.new(
        PositiveInteger           $major
        PositiveInteger           $minor
        PositiveInteger           $patch
        Optional[SemVerQualifier] $prerelease = undef
        Optional[SemVerQualifier] $build = undef
        )
function SemVer.new(SemVerHash $hash_args)

Examples:  



SemVer.new("1.2.3")

Creates a SemVer
                                                  instance from a string

SemVer.new(1, 2, 3, "rc4",
                                                  "5"

Creates a SemVer
                                                  instance from a list of arguments 

SemVer.new(major => 1,
                                                  minor => 2, patch => 3, prerelease => "rc4", build
                                                  =>"5")

 Creates a SemVer instance from a hash 


You can parameterize the SemVer type to
                                restrict which values the type matches. The values are defined by
                                one or more Strings or SemVerRanges. 
The full signatures are: 

SemVer[<String>] 

The <String> specifies a semantic
                                version string — representing a single version or range of versions.
                                A SemVer instance matches the
                                parameterized type, if the instance is within the range defined by
                                the type. For example:

$t = SemVer['> 1.0.0 < 2.0.0']
notice(SemVer('1.2.3') =~ $t) # true
notice(SemVer('2.3.4') =~ $t) # false

SemVer[ <SemVerRange>,  ( <SemVerRange>, ... ) ]
The SemVer type is accompanied by the
                                        SemVerRange type, which you
                                can define to restrict matches to a contiguous version range. For
                                example:

 $t = SemVer[SemVerRange('>=1.0.0 <2.0.0')]
notice(SemVer('1.2.3') =~ $t) # true
notice(SemVer('2.3.4') =~ $t) # false

When you define a parameterized SemVer
                                type using multiple ranges, and the instance is enclosed in at least
                                one of the ranges, the SemVer
                                instance matches the type.

$t = SemVer[SemVerRange('>=1.0.0 <2.0.0'), SemVerRange('>=3.0.0 <4.0.0')]
notice(SemVer('1.2.3') =~ $t) # true
notice(SemVer('2.5.0') =~ $t) # false
notice(SemVer('3.0.0') =~ $t) # true 

If any of the ranges are adjacent or overlap, they get normalized
                                (merged). For example, the following are equal: 

SemVer['>=1.0.0 <4.0.0']
SemVer[SemVerRange('>=1.0.0 <3.0.0'), SemVerRange('>=2.0.0 <4.0.0')] # overlap
SemVer[SemVerRange('>=1.0.0 <2.0.0'), SemVerRange('>=2.0.0 <4.0.0')] # adjacent


The SemVerRange data type
An instance of SemVerRange represents a
                                contiguous semantic version range. The string format of a SemVerRange is specified by the
                                        SemVer Range Grammar.
                                The SemVerRange type does not
                                support the logical or operator (||). 
You can create an instance of SemVerRange
                                        (SemVerRange.new) from a
                                String, individual values, or a hash of individual values. The
                                signatures
                                are:type SemVerRangeString = String[1]
type SemVerRangeHash = Struct[{
  min                   => Variant[default, SemVer],
  Optional[max]         => Variant[default, SemVer],
  Optional[exclude_max] => Boolean
}]

function SemVerRange.new(SemVerRangeString $semver_range_string)

function SemVerRange.new(
           Variant[default,SemVer] $min
           Variant[default,SemVer] $max
           Optional[Boolean]       $exclude_max = undef
         }

function SemVerRange.new(SemVerRangeHash $semver_range_hash)


Examples:



SemVerRange.new(">1.0.0"))

Creates a SemVerRange from a String

SemVerRange.new(SemVer.new("1.0.0"),
                                                  SemVer.new("2.0.0"), true)

Creates a SemVerRange instance from a list of
                                                  arguments.

SemVerRange.new(min =>
                                                  SemVer.new("1.0.0"), max => SemVer.new("2.0.0"),
                                                  exclude_max => true)

 Creates a SemVerRange instance from a hash. 


By default, the range includes the maximum value so that the following
                                examples are equal:

SemVerRange.new(">= 1.0.0 <= 2.0.0")
SemVerRange.new(SemVer.new("1.0.0"), SemVer.new("2.0.0")) 

The maximum value can be excluded so that the following examples are
                                equal:

SemVerRange.new(">= 1.0.0 < 2.0.0")
SemVerRange.new(SemVer.new("1.0.0"), SemVer.new("2.0.0"), true) 

Unlike the SemVer type, you cannot
                                paramatize the SemVerRange type, as
                                it represents all semantic version ranges.



Parent types

These abstract data types are the parents of multiple other types, and match values
      that would match any of their sub-types. They’re useful when you have very loose
      restrictions but not no restrictions.
The Scalar data type 
The Scalar data type matches all values of the
            following concrete data types: 

Numbers (both integers and floats) 


Strings 


Booleans 


Regular expressions



It doesn’t match undef, default, resource references, arrays, or hashes. It takes no
            parameters.
Scalar is equivalent to Variant[Integer, Float, String, Boolean, Regexp].

The ScalarData data type
The ScalarData data type represents a restricted set of
            "value" data types that have concrete direct representation in JSON. 
ScalarData is an alias for Variant[Integer, Float, String,
               Boolean].

The Data data type 
The Data data type matches any value that would match
               Scalar, but it also matches: 


undef



Arrays that only contain values that also match Data



Hashes whose keys match Scalar and whose values
                     also match Data




It doesn't match default or resource references. It
            takes no parameters.
Data is especially useful because it represents the
            subset of types that can be directly represented in almost all serialization format,
            such as JSON.

The Collection data type 
The Collection type matches any array or hash,
            regardless of what kinds of values or keys it contains. It only partially overlaps with
               Data— there are values, such as an array of resource
            references, that match Collection but do not match
               Data.
Collection is equivalent to Variant[Array[Any], Hash[Any, Any]].

The CatalogEntry data type 
The CatalogEntry data type is the parent type of Resource and Class. Like
            those types, the Puppet language contains no values that
            it ever matches. However, the type Type[CatalogEntry]
            matches any class reference or resource reference. It takes no parameters.

The Any data type 
The Any data type matches any value of any
            data type.

The Iterable data type
The Iterable data type represents all data types that can be iterated;
            in other words, all data types where the value is some kind of container of individual
            values. The Iterable type is abstract in that it does not specify if it
            represents a concrete data type (such as Array) that has storage in
            memory, of if it is an algorithmic construct like a transformation function (such as the
               step function).

The Iterator data type
The Iterator data type is an Iterable that does not
            have a concrete backing data type holding a copy of the values it will produce when
            iterated over. It represents an algorithmic transformation of some source (which in turn
            can be algorithmic). 
An Iterator may not be assigned to an attribute of a
            resource, and it may not be used as an argument to version 3.x functions. To create a
            concrete value an Iterator must be "rolled out" by using
            a function at the end of a chain that produces a concrete value.

The RichData data type
The RichData data type represents the abstract notion of
            "serializeable" and includes all the types in the type system except
               Runtime, Callable, Iterator, and
               Iterable. It is expressed as an alias of Variant[Default, Object, Scalar, SemVerRange, Type, Undef, Array[RichData],
               Hash[RichData, RichData]].



Other types

These types aren’t quite like the others.
The Callable data type 
The Callable data type matches callable
            lambdas provided as function arguments.
There is no way to interact with Callable values in the Puppet language,
            but Ruby functions written to the function API (Puppet::Functions) can use Callable to inspect the lambda provided to the function.
The full signature for Callable
            is:Callable[ (<DATA TYPE>, ...,) <MIN COUNT>, <MAX COUNT>, <BLOCK TYPE> ]

All of these parameters are optional. 










Position
Parameter
Data type
Default value
Description




1 to n
Data type
Type
none
Any number of data types, representing the data type of each argument
                           the lambda accepts.


-3 (third last)
Minimum count
Integer
0
The minimum number of arguments the lambda accepts. This parameter
                           accepts the value default, which
                           uses its default value 0. 


-2 (second last)
Maximum count
Integer
infinity
The maximum number of arguments the lambda accepts. This parameter
                           accepts the value default, which
                           uses its default value, infinity. 


-1 (last)
Block type
Type[Callable]
none
The block_type of the
                           lambda. 






 




          Was this page helpful?
        
Yes
No







              Don’t fill this out if you’re human: 






Thank you for your feedback!

            Feel free to add a comment or suggestion.
            





Send
Please enter your feedback





              Don’t fill this out if you’re human: 







            We’re sorry to hear that! 
            Please tell us why so we can help.
          

            Enter your feedback and email. This form is sent to the Puppet docs team.
            We ask for your email as we might contact you regarding your feedback.
          

            If you need help with the product itself, visit Puppet Support
            or ask in Puppet Community on Slack.
          

            Feedback:
            






            Email Address:
            






            To learn about how Puppet uses your personal information,
            visit our privacy policy.
          


Send
Please enter your feedback and contact email

          If you leave us your email, we may contact you regarding your feedback.
          For more information on how Puppet uses your personal information, see
          our
          privacy policy.
        





            Don’t fill this out if you’re human: 








    See an issue? Please file a JIRA ticket in our
    [DOCUMENTATION]
      project.
  











Puppet by Perforce gives IT operations teams back their time and offers peace of mind with infrastructure automation that enables security and compliance.






Legal
Privacy Policy
Terms of Use
Security


©  Puppet, Inc., a Perforce company. All rights reserved.




Puppet and other identified trademarks are the property of Puppet, Inc., Perforce Software, Inc., or an affiliate. Such trademarks are claimed and/or registered in the U.S. and other countries and regions. All third-party trademarks are the property of their respective holders. References to third-party trademarks do not imply endorsement or sponsorship of any products or services by the trademark holder. Contact Puppet, Inc., for further details.

