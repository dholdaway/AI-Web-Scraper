Title: CWE -

		CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') (4.15)                
URL: https://cwe.mitre.org/data/definitions/113.html

Common Weakness Enumeration
A community-developed list of SW & HW weaknesses that can become vulnerabilities



 






Home  >  CWE List  >  

                CWE- Individual Dictionary Definition (4.15)                		 
		




	ID Lookup:








 





Home


About ▼

About
New to CWE
User Stories
Videos
History
Documents
FAQs
Glossary





CWE List ▼

Latest Version
Downloads
Reports
Visualizations
Archive





Mapping ▼

Root Cause Mapping Guidance
Root Cause Mapping Quick Tips
Root Cause Mapping Examples





Top-N Lists ▼

Top 25 Software
Top Hardware
Top 10 KEV Weaknesses





Community ▼

Community
Working Groups & Special Interest Groups
Board
Board Meeting Minutes
CWE Discussion List
CWE Discussion Archives
Contribute Weakness Content to CWE





News ▼

Current News
X-Twitter 
Mastodon 
LinkedIn 
YouTube 
Podcast 
Medium 
News Archive

Search






















CWE Glossary Definition











 CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')Weakness ID: 113Vulnerability Mapping: 
											ALLOWEDThis CWE ID may be used to map to real-world vulnerabilitiesAbstraction: VariantVariant - a weakness that is linked to a certain type of product, typically involving a specific language or technology. More specific than a Base weakness. Variant level weaknesses typically describe issues in terms of 3 to 5 of the following dimensions: behavior, property, technology, language, and resource.


View customized information: 

Conceptual
For users who are interested in more notional aspects of a weakness. Example: educators, technical writers, and project/program managers.


Operational
For users who are concerned with the practical application and details about the nature of a weakness and how to prevent it from happening. Example: tool developers, security researchers, pen-testers, incident response analysts.


Mapping Friendly
For users who are mapping an issue to CWE/CAPEC IDs, i.e., finding the most appropriate CWE for a specific issue (e.g., a CVE record).  Example: tool developers, security researchers.


Complete
For users who wish to see all available information for the CWE/CAPEC entry.


Custom
For users who want to customize what details are displayed.






×

Edit Custom Filter

Conceptual
Operational
Mapping Friendly
Select All









Reset
Clear
Submit
Cancel






 DescriptionThe product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.  Extended DescriptionHTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. When an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as "splitting" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \r, and LF is line feed, also given by %0a or \n. In addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \t) and SP (space, also given as + sign or %20). These types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second "split" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks. HTTP response splitting weaknesses may be present when: Data enters a web application through an untrusted source, most frequently an HTTP request. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.  Alternate Terms
HTTP Request Splitting
HTTP Response Splitting
 Common ConsequencesThis table specifies different individual consequences associated with the weakness. The Scope identifies the application security area that is violated, while the Impact describes the negative technical impact that arises if an adversary succeeds in exploiting this weakness. The Likelihood provides information about how likely the specific consequence is expected to be seen relative to the other consequences in the list. For example, there may be high likelihood that a weakness will be exploited to achieve a certain impact, but a low likelihood that it will be exploited to achieve a different impact.ScopeImpactLikelihoodIntegrityAccess ControlTechnical Impact: Modify Application Data; Gain Privileges or Assume IdentityCR and LF characters in an HTTP header may give attackers control of the remaining headers and body of the message that the application intends to send/receive, as well as allowing them to create additional messages entirely under their control.  Potential Mitigations
Phase:  ImplementationStrategy:  Input ValidationConstruct HTTP headers very carefully, avoiding the use of non-validated input data. 
Phase:  ImplementationStrategy:  Input Validation Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. If an input does not strictly conform to specifications, reject it or transform it into something that conforms.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."  Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  
Phase:  ImplementationStrategy:  Output EncodingUse and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. 
Phase:  ImplementationStrategy:  Input ValidationInputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked. 
 RelationshipsThis table shows the weaknesses and high level categories that are related to this weakness. These relationships are defined as ChildOf, ParentOf, MemberOf and give insight to similar items that may exist at higher and lower levels of abstraction. In addition, relationships such as PeerOf and CanAlsoBe are defined to show similar weaknesses that the user may want to explore. Relevant to the view "Research Concepts" (CWE-1000)NatureTypeIDNameChildOfClass - a weakness that is described in a very abstract fashion, typically independent of any specific language or technology. More specific than a Pillar Weakness, but more general than a Base Weakness. Class level weaknesses typically describe issues in terms of 1 or 2 of the following dimensions: behavior, property, and resource.436Interpretation ConflictChildOfBase - a weakness 
that is still mostly independent of a resource or technology, but with sufficient details to provide specific methods for detection and prevention. Base level weaknesses typically describe issues in terms of 2 or 3 of the following dimensions: behavior, property, technology, language, and resource.93Improper Neutralization of CRLF Sequences ('CRLF Injection')CanPrecedeBase - a weakness 
that is still mostly independent of a resource or technology, but with sufficient details to provide specific methods for detection and prevention. Base level weaknesses typically describe issues in terms of 2 or 3 of the following dimensions: behavior, property, technology, language, and resource.79Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')This table shows the weaknesses and high level categories that are related to this weakness. These relationships are defined as ChildOf, ParentOf, MemberOf and give insight to similar items that may exist at higher and lower levels of abstraction. In addition, relationships such as PeerOf and CanAlsoBe are defined to show similar weaknesses that the user may want to explore. Relevant to the view "Seven Pernicious Kingdoms" (CWE-700)NatureTypeIDNameChildOfClass - a weakness that is described in a very abstract fashion, typically independent of any specific language or technology. More specific than a Pillar Weakness, but more general than a Base Weakness. Class level weaknesses typically describe issues in terms of 1 or 2 of the following dimensions: behavior, property, and resource.20Improper Input Validation Modes Of IntroductionThe different Modes of Introduction provide information about how and when this weakness may be introduced. The Phase identifies a point in the life cycle at which introduction may occur, while the Note provides a typical scenario related to introduction during the given phase.PhaseNoteImplementation Applicable PlatformsThis listing shows possible areas for which the given weakness could appear. These may be for specific named Languages, Operating Systems, Architectures, Paradigms, Technologies, or a class of such platforms. The platform is listed along with how frequently the given weakness appears for that instance.Languages Class: Not Language-Specific (Undetermined Prevalence)Technologies Class: Web Based (Undetermined Prevalence) Demonstrative ExamplesExample 1The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.(bad code)Example Language: Java 
String author = request.getParameter(AUTHOR_PARAM);...Cookie cookie = new Cookie("author", author);cookie.setMaxAge(cookieExpiration);response.addCookie(cookie);
Assuming a string consisting of standard alpha-numeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:(result) 
HTTP/1.1 200 OK...Set-Cookie: author=Jane Smith...
However, because the value of the cookie is composed of unvalidated user input, the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as(attack code) 
Wiley Hacker\r\nHTTP/1.1 200 OK\r\n
then the HTTP response would be split into two responses of the following form:(result) 
HTTP/1.1 200 OK...Set-Cookie: author=Wiley HackerHTTP/1.1 200 OK...
The second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability to construct arbitrary HTTP responses permits a variety of resulting attacks, including:


cross-user defacement


web and browser cache poisoning


cross-site scripting


page hijacking


Example 2An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server.
Cross-User Defacement can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server.


                              In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application.
                           

                              In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.
                           

Example 3The impact of a maliciously constructed response can be magnified if it is cached, either by a web cache used by multiple users or even the browser cache of a single user.
Cache Poisoning: if a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although the user of the local browser instance will be affected.
Example 4Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users.
Cross-Site Scripting: cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser.
The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.
The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.
Example 5In addition to using a vulnerable application to send malicious content to a user, the same weakness can also be leveraged to redirect sensitive content generated by the server to the attacker instead of the intended user.
Page Hijacking: by submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server to the attacker instead of the intended user.
Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.
 Observed ExamplesReferenceDescription
CVE-2020-15811Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning 
CVE-2021-41084Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs 
CVE-2018-12116Javascript-based framework allows request splitting through a path option of an HTTP request 
CVE-2004-2146Application accepts CRLF in an object ID, allowing HTTP response splitting. 
CVE-2004-1656Shopping cart allows HTTP response splitting to perform HTML injection via CRLF in a parameter for a url 
CVE-2005-2060Bulletin board allows response splitting via CRLF in parameter. 
CVE-2004-2512Response splitting via CRLF in PHPSESSID. 
CVE-2005-1951e-commerce app allows HTTP response splitting using CRLF in object id parameters 
 Detection Methods
 Automated Static AnalysisAutomated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect "sources" (origins of input) with "sinks" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) Effectiveness: High
 MembershipsThis MemberOf Relationships table shows additional CWE Categories and Views that reference this weakness as a member. This information is often useful in understanding where a weakness fits within the context of external information sources.NatureTypeIDNameMemberOfView - a subset of CWE entries that provides a way of examining CWE content. The two main view structures are Slices (flat lists) and Graphs (containing relationships between entries).884CWE Cross-sectionMemberOfCategory - a CWE entry that contains a set of other entries that share a common characteristic.990SFP Secondary Cluster: Tainted Input to CommandMemberOfCategory - a CWE entry that contains a set of other entries that share a common characteristic.1347OWASP Top Ten 2021 Category A03:2021 - InjectionMemberOfCategory - a CWE entry that contains a set of other entries that share a common characteristic.1409Comprehensive Categorization: Injection Vulnerability Mapping Notes Usage: ALLOWED(this CWE ID could be used to map to real-world vulnerabilities)Reason: Acceptable-Use Rationale: This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.  Comments: Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.  Taxonomy MappingsMapped Taxonomy NameNode IDFitMapped Node Name
PLOVERHTTP response splitting
7 Pernicious KingdomsHTTP Response Splitting
WASC25HTTP Response Splitting
Software Fault PatternsSFP24Tainted input to command
 Related Attack PatternsCAPEC-IDAttack Pattern Name
CAPEC-105HTTP Request Splitting
CAPEC-31Accessing/Intercepting/Modifying HTTP Cookies
CAPEC-34HTTP Response Splitting
CAPEC-85AJAX Footprinting
 References
[REF-43] OWASP. "OWASP TOP 10". 2007-05-18. 
				<https://github.com/owasp-top/owasp-top-2007>. 
[REF-44] Michael Howard, David LeBlanc
							and John Viega. "24 Deadly Sins of Software Security". "Sin 2: Web-Server Related Vulnerabilities (XSS, XSRF, and Response Splitting)." Page 31. McGraw-Hill. 2010. 
				
[REF-1272] Robert Auger. "HTTP Request Splitting". 2011-02-01. 
				<http://projects.webappsec.org/w/page/13246929/HTTP%20Request%20Splitting>. 
 Content History SubmissionsSubmission DateSubmitterOrganization2006-07-19(CWE Draft 3, 2006-07-19)PLOVER ContributionsContribution DateContributorOrganization2022-02-25(CWE 4.9, 2022-10-13)Jonathan LeitschuhDan Kaminsky Fellowship @ HUMAN SecuritySuggested a new entry for HTTP Request Splitting, leading to scope expansion for CWE-113  ModificationsModification DateModifierOrganization2008-07-01Eric DalciCigitalupdated References, Potential_Mitigations, Time_of_Introduction2008-09-08CWE Content TeamMITREupdated Relationships, Observed_Example, Other_Notes, References, Taxonomy_Mappings2008-10-14CWE Content TeamMITREupdated Description2008-11-24CWE Content TeamMITREupdated Description, Other_Notes2009-03-10CWE Content TeamMITREupdated Demonstrative_Examples2009-05-27CWE Content TeamMITREupdated Name2009-07-27CWE Content TeamMITREupdated Demonstrative_Examples, Potential_Mitigations2009-10-29CWE Content TeamMITREupdated Common_Consequences, Description, Other_Notes, Theoretical_Notes2010-02-16CWE Content TeamMITREupdated Taxonomy_Mappings2010-06-21CWE Content TeamMITREupdated Description, Name2011-03-29CWE Content TeamMITREupdated Potential_Mitigations2011-06-01CWE Content TeamMITREupdated Common_Consequences, Description2012-05-11CWE Content TeamMITREupdated Common_Consequences, References, Relationships2012-10-30CWE Content TeamMITREupdated Potential_Mitigations2014-06-23CWE Content TeamMITREupdated Demonstrative_Examples2014-07-30CWE Content TeamMITREupdated Relationships, Taxonomy_Mappings2015-12-07CWE Content TeamMITREupdated Relationships2017-05-03CWE Content TeamMITREupdated Related_Attack_Patterns2017-11-08CWE Content TeamMITREupdated Applicable_Platforms, Demonstrative_Examples2019-06-20CWE Content TeamMITREupdated Relationships2020-02-24CWE Content TeamMITREupdated Applicable_Platforms, Potential_Mitigations, Relationships, Type2020-06-25CWE Content TeamMITREupdated Potential_Mitigations2021-10-28CWE Content TeamMITREupdated Relationships2022-06-28(CWE 4.8, 2022-06-28)CWE Content TeamMITREExtended the abstraction of this entry to include both HTTP request and response splitting.2022-06-28(CWE 4.8, 2022-06-28)CWE Content TeamMITREupdated Alternate_Terms, Common_Consequences, Demonstrative_Examples, Description, Name, Observed_Examples, Potential_Mitigations, References, Relationships, Theoretical_Notes2022-10-13(CWE 4.9, 2022-10-13)CWE Content TeamMITREupdated Demonstrative_Examples, Related_Attack_Patterns2023-01-31(CWE 4.10, 2023-01-31)CWE Content TeamMITREupdated Description2023-04-27(CWE 4.11, 2023-04-23)CWE Content TeamMITREupdated Detection_Factors, References, Relationships2023-06-29CWE Content TeamMITREupdated Mapping_Notes Previous Entry NamesChange DatePrevious Entry Name2008-04-11(CWE Draft 9)HTTP Response Splitting2009-05-27(CWE 1.4)Failure to Sanitize CRLF Sequences in HTTP Headers (aka 'HTTP Response Splitting')2010-06-21(CWE 1.9)Failure to Sanitize CRLF Sequences in HTTP Headers ('HTTP Response Splitting')2022-06-28(CWE 4.8)Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting') 
More information is available — Please edit the custom filter or select a different filter.






Page Last Updated: 

            July 16, 2024              




 









Site Map | 
            Terms of Use | 
            Manage Cookies | 
            Cookie Notice | 
            Privacy Policy | 
            Contact Us | 
            






Use of the Common Weakness Enumeration (CWE™) and the associated references from this website are subject to the Terms of Use. CWE is sponsored by the U.S. Department of Homeland Security (DHS) Cybersecurity and Infrastructure Security Agency (CISA) and managed by the Homeland Security Systems Engineering and Development Institute (HSSEDI) which is operated by The MITRE Corporation (MITRE). Copyright © 2006–2024, The MITRE Corporation. CWE, CWSS, CWRAF, and the CWE logo are trademarks of The MITRE Corporation.

